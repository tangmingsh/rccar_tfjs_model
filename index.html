<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TFJS AI RCCar</title>
</head>
<body>
<video autoplay playsinline muted id="webcam" width="300" height="300"></video>
<div id="predictText"></div>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.4.0"> </script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
<!--<script src="tfjs2.4.js"></script>-->
<script>
    // const videoElement = document.createElement('video');
    async function  app(){
        // 获取camera标签
        const video = document.getElementById('webcam');
        // 设置后置相机
        // navigator.getMedia = navigator.getUserMedia;
        // // await navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: { exact: "environment" } } })
        // await navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: 'user'} })
        //     .then(stream => {
        //         video.srcObject = stream
        //         video.onloadedmetadata = () => {
        //             video.play()
        //         }
        //     })
        const camconfig = {
            facingMode:'environment'
        }

        const webcam = await tf.data.webcam(video,camconfig);
        // Create an object from Tensorflow.js data API which could capture image
        // from the web camera as Tensor.
        const modelUrl = 'https://cdn.jsdelivr.net/gh/tangmingsh/rccar_tfjs_model/model.json'
        const model = await tf.loadLayersModel(modelUrl);
        const label = ['直行','左转','右转','停止'];
        model.summary();

        while (true) {
            const img = await webcam.capture();
            // const result = await net.classify(img);
            // Dispose the tensor to release the memory.
            // img.print();
            // console.log(img);
            const image = img;
            let tpl = ''

            const resized_image = tf.image.resizeBilinear(image, [224,224]).toFloat();
            const offset = tf.scalar(255.0);
            const normalized = tf.scalar(1.0).sub(resized_image.div(offset));
            const batchedImage = normalized.expandDims(0);
            const result = await model.predict(batchedImage).data();
            console.log(result);
            let text = label.map((label, index) => ({ label, score: result[index] })).sort((a,b)=>b.score - a.score)
            console.log(label.map((label, index) => ({ label, score: result[index] })).sort((a,b)=>b.score - a.score))
            text.forEach((e)=>{
                tpl +=`<p>${e.label},评分${e.score}</p>`

            })
            predictText.innerHTML = tpl;
            // await predict(image);
            img.dispose();

            // Give some breathing room by waiting for the next animation frame to
            // fire.
            await tf.nextFrame();
        }
    }
    app();
</script>
</body>
</html>