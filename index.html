<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI RCCar</title>
</head>
<body>
<video autoplay playsinline muted id="webcam" width="224" height="224"></video>
<div id="predictText"></div>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.4.0"> </script>
<!--<script src="tfjs2.4.js"></script>-->
<script>
    // const videoElement = document.createElement('video');
    async function  app(){
        if ('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices) {
            console.log("Let's get this party started")
        }
        await navigator.mediaDevices.getUserMedia({video: true});

        const webcamElement = document.getElementById('webcam');
        const constraints = {
            advanced: [{
                facingMode: "environment"
            }]
        };
        await navigator.mediaDevices.getUserMedia({webcamElement: constraints}).then((stream) => {
                webcamElement.src = window.URL.createObjectURL(stream);
                webcamElement.play();
            });

        // Create an object from Tensorflow.js data API which could capture image
        // from the web camera as Tensor.
        const webcam = await tf.data.webcam(webcamElement);


        const modelUrl = 'https://cdn.jsdelivr.net/gh/tangmingsh/rccar_tfjs_model/model.json'
        const model = await tf.loadLayersModel(modelUrl);
        const label = ['直行','停止','左转','右转'];
        model.summary();

        while (true) {
            const img = await webcam.capture();
            // const result = await net.classify(img);
            // Dispose the tensor to release the memory.
            // img.print();
            // console.log(img);
            const image = img;
            let tpl = ''

            const resized_image = tf.image.resizeBilinear(image, [224,224]).toFloat();
            const offset = tf.scalar(255.0);
            const normalized = tf.scalar(1.0).sub(resized_image.div(offset));
            const batchedImage = normalized.expandDims(0);
            const result = await model.predict(batchedImage).data();
            console.log(result);
            let text = label.map((label, index) => ({ label, score: result[index] })).sort((a,b)=>b.score - a.score)
            console.log(label.map((label, index) => ({ label, score: result[index] })).sort((a,b)=>b.score - a.score))
            text.forEach((e)=>{
                tpl +=`<p>${e.label},评分${e.score}</p>`

            })
            predictText.innerHTML = tpl;
            // await predict(image);
            img.dispose();

            // Give some breathing room by waiting for the next animation frame to
            // fire.
            await tf.nextFrame();
        }
    }

    app();

</script>
</body>
</html>